<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CommonQ's Blog</title><link>http://commonq.github.io/</link><description></description><atom:link href="http://commonq.github.io/feeds/commonq.rss.xml" rel="self"></atom:link><lastBuildDate>Thu, 01 May 2014 00:00:00 +0800</lastBuildDate><item><title>Android JNI和NDK学习(4)--编译与预编译</title><link>http://commonq.github.io/Android_ndk_4.html</link><description>&lt;h3&gt;打包so文件&lt;/h3&gt;
&lt;p&gt;在apk里打包进.so文件的方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;是在Android.mk文件里增加
LOCAL_JNI_SHARED_LIBRARIES := libxxx
这样在编译的时候，NDK自动会把这个libxxx打包进apk；
放在youapk/lib/目录下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是在应用的目录下手工建
libs/armeabi
目录，然后把libxxx.so拷贝到这个目录下，
这样NDK就会自动把这个libxxx.so打包进apk，位置还是在
放在yourapk/lib/目录下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在代码里，使用
&lt;code&gt;System.loadLibrary("xxx");&lt;/code&gt;
就可以加载这个动态库了。
这里要注意，参数只写xxx就可以了，不需要写libxxx，也不需要写libxxx.so。&lt;/p&gt;
&lt;p&gt;还有一点要说明，System.loadLibrary这个函数会在如下路径搜索libxxx.so文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;apk&lt;/span&gt; &lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但，如果libxxx.so还依赖其它.so文件，比如libyyy.so，则System.loadLibrary&lt;strong&gt;只会
在/system/lib目录下去找，如果没找到，它不会自动到/data/data/you apk package/lib
下去找&lt;/strong&gt;，这个时候就会报动态库没找到的错；
解决方法是在load libxxx.so之前，先load libyyy.so，如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loadLibrary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;yyy&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loadLibrary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;xxx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;声明一个预编译库的模块&lt;/h3&gt;
&lt;p&gt;对于Android编译工具而言，每个预编译库必须声明为一个独立的模块。这里举一个例子，假设 libfoo.so 文件与 Android.mk 位于同一个目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;LOCAL_PATH&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;include&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLEAR_VARS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;LOCAL_MODULE&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;prebuilt&lt;/span&gt;  
&lt;span class="n"&gt;LOCAL_SRC_FILES&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;libfoo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;  
&lt;span class="n"&gt;include&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PREBUILT_SHARED_LIBRARY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;按以下步骤声明这样一个模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给该模块取一个名字（这里是 foo-prebuilt）。这个名字不需要与预编译库自身的名字相同。&lt;/li&gt;
&lt;li&gt;将 LOCAL_SRC_FILES 指定为你要提供的共享库的路径。通常，该路径是相对于 LOCAL_PATH 的路径。注意：必须保证共享库ABI的兼容性。&lt;/li&gt;
&lt;li&gt;如果你的库是共享库，则包含 PREBUILT_SHARED_LIBRARY 而不是 BUILD_SHARED_LIBRARY；如果是静态库，则包含 PREBUILT_STATIC_LIBRARY。
预编译模块不需要编译。该预编译模块会被拷贝到 $PROJECT/obj/local 下面，还会被拷贝到 $PROJECT/libs/&lt;abi&gt; 下面（这里的库被strip过）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;在其他模块中引用这个预编译库&lt;/h3&gt;
&lt;p&gt;在依赖该预编译库的模块对应的Android.mk中，将预编译库的名字（前面取的）加入到 LOCAL_STATIC_LIBRARIES 或 LOCAL_SHARED_LIBRARIES 声明中。例如，一个使用上面libfoo.so的简单例子如下：
&lt;code&gt;include $(CLEAR_VARS)  
LOCAL_MODULE := foo-user  
LOCAL_SRC_FILES := foo-user.c  
LOCAL_SHARED_LIBRARIES := foo-prebuilt  
include $(BUILD_SHARED_LIBRARY)&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">CommonQ</dc:creator><pubDate>Thu, 01 May 2014 00:00:00 +0800</pubDate><guid>tag:commonq.github.io,2014-05-01:Android_ndk_4.html</guid><category>Android</category><category>NDK</category></item><item><title>Android JNI和NDK学习(5)--JNI分析API</title><link>http://commonq.github.io/Android_ndk_5.html</link><description>&lt;h3&gt;Java类型和本地类型对应&lt;/h3&gt;
&lt;p&gt;在如下情况下，需要在本地方法中应用java对象的引用，就会用到类型之间的转换：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;java方法里面将参数传入本地方法；&lt;/li&gt;
&lt;li&gt;在本地方法里面创建java对象；&lt;/li&gt;
&lt;li&gt;在本地方法里面return结果给java程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Java基本类型&lt;/h4&gt;
&lt;p&gt;像booleans、integers、floats等从Java程序中传到本地方法中的原始类型可以直接使用，下面是java中的原始类型和本地方法中的类型的对应：&lt;/p&gt;
&lt;p&gt;Java 类型本地类型说明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;jboolean&lt;/span&gt; &lt;span class="err"&gt;无符号，&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt;  
&lt;span class="n"&gt;byte&lt;/span&gt; &lt;span class="n"&gt;jbyte&lt;/span&gt; &lt;span class="err"&gt;无符号，&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt;  
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;jchar&lt;/span&gt; &lt;span class="err"&gt;无符号，&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt;    
&lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="n"&gt;jshort&lt;/span&gt; &lt;span class="err"&gt;有符号，&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;jint&lt;/span&gt; &lt;span class="err"&gt;有符号，&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt;  
&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;jlong&lt;/span&gt; &lt;span class="err"&gt;有符号，&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt;  
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;jfloat&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt;  
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;jdouble&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是说如果我在方法中传进去了一个boolean的参数的话，那么我在本地方法中就有jboolean类型与之对应。同理，如果在本地方法中return一个jint的话，那么在java中就返回一个int类型。&lt;/p&gt;
&lt;p&gt;为了使用方便，特提供以下定义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#define JNI_FALSE 0&lt;/span&gt;
&lt;span class="c"&gt;#define JNI_TRUE 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;jsize 整数类型用于描述主要指数和大小：
typedef jint jsize;&lt;/p&gt;
&lt;h3&gt;Java String类型&lt;/h3&gt;
&lt;p&gt;在java中，使用的字符串String对象是Unicode码，即每个字符不论是中文还是英文或是符号，一个字符总是占用两个字节。
在c/c++本地代码中创建java的String对象
.java通过JNI接口可以将java的字符串转换到c/c++中的宽字符串(wchar_t &lt;em&gt;),或是传回一个UTF-8的字符串（char &lt;/em&gt;）到c/c++。反过来，c/c++可以通过一个宽字符串，或是一个UTF-8编码的字符串来创建一个java端的String对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;GetStringChars&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;GetStringUTFChars&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;.这两个函数用来取得与某个jstring对象相关的java字符串。分别可以取得UTF-16编码的宽字符串（jchar&lt;em&gt;）跟UTF-8编码的字符串（char&lt;/em&gt;）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Const&lt;/span&gt; &lt;span class="n"&gt;jchar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;GetStringChars&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jstring&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jboolean&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;copied&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;GetStringUTFChars&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jstring&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jboolean&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;copied&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一个参数传入一个指向java中的String对象的jstring变量&lt;br /&gt;
第二个参数传入的是一个jboolean的指针。&lt;br /&gt;
这两个函数分别都会有两个不同的动作：&lt;br /&gt;
&lt;strong&gt;第一个参数：&lt;/strong&gt;&lt;br /&gt;
1.  开新内存，然后把java中的String拷贝到这个内存中，然后返回这个内存地址的指针。&lt;br /&gt;
2.  直接返回指向java中string的内存的指针，这个时候千万不要改变这个内存的内容，这将破坏String在java中始终是常量这个原则。&lt;br /&gt;
&lt;strong&gt;第二个参数：&lt;/strong&gt;&lt;br /&gt;
是用来标示是否对java的string对象进行了拷贝的。
如果传入的这个jboolean指针不是null,则他会给该指针指向的内存传入JNI_TRUE或JNI_FALSE标示是否进行了拷贝。
传入null标示不关心是否拷贝字符串，它就不会给jboolean*指向的内存赋值。
使用这两个函数取得的字符串，在不使用的时候，要使用&lt;code&gt;ReleaseStringChars/ReleaseStringUTFChars&lt;/code&gt;来释放拷贝的内存，或是释放对java的String对象的引用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ReleaseStringChars&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jstring&lt;/span&gt; &lt;span class="n"&gt;jstr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;jchar&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ReleaseStringUTFChars&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jstring&lt;/span&gt; &lt;span class="n"&gt;jstr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一个参数指定一个jstring变量，即是要释放的本地字符串的来源。&lt;br /&gt;
第二个参数就是要释放的本地字符串  &lt;/p&gt;
&lt;h3&gt;访问类对象的属性&lt;/h3&gt;
&lt;p&gt;env 为 JNIEnv,obj的类型为jobject&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;JAVA_FieldAccessTest_accessField&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JNIEnv&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;jobject&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;

     &lt;span class="n"&gt;jfieldID&lt;/span&gt; &lt;span class="n"&gt;fid&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
     &lt;span class="n"&gt;jclass&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetObjectClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="c1"&gt;//类FieldAccessTest中有个String类型的属性s&lt;/span&gt;

     &lt;span class="c1"&gt;//获取要访问的属性的id&lt;/span&gt;
     &lt;span class="n"&gt;fid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetFieldID&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evn&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;s&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Ljava/lang/String;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//读取属性值&lt;/span&gt;
    &lt;span class="n"&gt;jstring&lt;/span&gt; &lt;span class="n"&gt;jstr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetObjectField&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fid&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;evn&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetStringUTFChars&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;jstr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;NULL&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//释放资源&lt;/span&gt;
   &lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ReleaseStringUTFChars&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;jstr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//现在反过来，改变调用该本地方法的java对象的属性值&lt;/span&gt;
    &lt;span class="n"&gt;jstr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NewStringUTF&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;88888&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetObjectField&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fid&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;jstr&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;总结：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;jfieldID&lt;/span&gt; &lt;span class="n"&gt;fid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetFieldID&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="err"&gt;对象所属的类的&lt;/span&gt;&lt;span class="n"&gt;jclass&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="err"&gt;属性名&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="err"&gt;属性对应的属性描述符号&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetObjectField&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="err"&gt;对象&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="err"&gt;属性&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;访问静态属性：&lt;/h4&gt;
&lt;p&gt;假如有个类如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StaticFielcTest&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;si&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
       &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;native&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;accessField&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
 &lt;span class="o"&gt;}&lt;/span&gt;
 &lt;span class="err"&gt;```&lt;/span&gt;

&lt;span class="err"&gt;那么实现为&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;

  &lt;span class="n"&gt;JNIEXPORT&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;JNICALL&lt;/span&gt;
   &lt;span class="nf"&gt;Java_StaticFieldTest_accessField&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JNIEnv&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jobject&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;

       &lt;span class="n"&gt;jfieldID&lt;/span&gt; &lt;span class="n"&gt;fid&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;   &lt;span class="cm"&gt;/* store the field ID */&lt;/span&gt;
       &lt;span class="n"&gt;jint&lt;/span&gt; &lt;span class="n"&gt;si&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
       &lt;span class="n"&gt;jclass&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetObjectClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//获取类class&lt;/span&gt;
       &lt;span class="n"&gt;fid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetStaticFieldID&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;si&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//获取静态属性id&lt;/span&gt;
       &lt;span class="n"&gt;si&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetStaticIntField&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fid&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//读去属性的值&lt;/span&gt;
      &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetStaticIntField&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fid&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//设置静态属性的值&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="err"&gt;```&lt;/span&gt;





&lt;span class="err"&gt;###访问实例方法&lt;/span&gt;
&lt;span class="err"&gt;假如有个这样的类：&lt;/span&gt;
&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;
 &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MethodCall&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;native&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;nativeMethod&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
       &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;callback&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
           &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;In Java CallBack&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
       &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;[])&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
           &lt;span class="n"&gt;MethodCall&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MethodCall&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
           &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;nativeMethod&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
           &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;loadLibrary&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;InstanceMethodCall&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;jni实现:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;JNIEXPORT&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;JNICALL&lt;/span&gt;
   &lt;span class="nf"&gt;Java_MethodCall_nativeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JNIEnv&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jobject&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="c1"&gt;//1.拿到class&lt;/span&gt;
       &lt;span class="n"&gt;jclass&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetObjectClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;                         
       &lt;span class="c1"&gt;//2.拿到方法id&lt;/span&gt;
       &lt;span class="n"&gt;jmethodID&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetMethodID&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;callback&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;()V&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;           
        &lt;span class="c1"&gt;//3.根据obj,和方法id 调用方法&lt;/span&gt;
      &lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;)-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;CallVoidMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;   
   &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据方法的返回值来决定调用哪个方法：
    Call&lt;Type&gt;Method
如果返回int  那么最后一步就调用  &lt;code&gt;(*env)-&amp;gt;CallIntMethod(env,obj,mid)&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;最后那个参数 "()V"   是方法描述符:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt;   &lt;span class="err"&gt;带一个&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="err"&gt;类型的参数，返回值类型为&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;     &lt;span class="err"&gt;没有参数，返回&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;   &lt;span class="c1"&gt;//注意！！没有参数并不是  (V)D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法public static void main(String[] args) 对应的方法描的符为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Ljava&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;;)&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;访问静态方法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;jclass&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetObjectClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;jmethodID&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetStaticMethodID&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;callback&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;()V&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;CallStaticVoidMethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//注意，这里跟访问实例方法的区别是 第二个参数不是obj,而是cls&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">CommonQ</dc:creator><pubDate>Thu, 01 May 2014 00:00:00 +0800</pubDate><guid>tag:commonq.github.io,2014-05-01:Android_ndk_5.html</guid><category>Android</category><category>NDK</category></item><item><title>Android JNI和NDK学习(1)--搭建开发环境</title><link>http://commonq.github.io/Android_ndk_1.html</link><description>&lt;h3&gt;NDK简介&lt;/h3&gt;
&lt;p&gt;NDK的好处:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="err"&gt;代码的保护，由于&lt;/span&gt;&lt;span class="n"&gt;apk&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="err"&gt;层代码很容易被反编译，而&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;库反汇难度较大。&lt;/span&gt;

&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="err"&gt;在&lt;/span&gt;&lt;span class="n"&gt;NDK&lt;/span&gt;&lt;span class="err"&gt;中调用第三方&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;库，因为大部分的开源库都是用&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;代码编写的。&lt;/span&gt;

&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="err"&gt;便于移植，用&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;写得库可以方便在其他的嵌入式平台上再次使用。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Linux下NDK环境搭建&lt;/h3&gt;
&lt;p&gt;android的NDK开发需要在linux下进行： 因为需要把C/C++编写的代码生成能在arm上运行的.so文件，这就需要用到交叉编译环境，而交叉编译需要在linux系统下才能完成。
安装&lt;code&gt;android-ndk&lt;/code&gt;开发包，在google android 官网下载： 通过这个开发包的工具才能将android jni 的C/C++的代码编译成库
android应用程序开发环境： 包括eclipse、java、 android sdk、 adt等。
安装完之后，需要将android-ndk的路劲加到环境变量PATH中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;gedit&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;environment&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在environment的PATH环境变量中添加你的&lt;code&gt;android-ndk&lt;/code&gt;的安装路劲，然后再让这个更改的环境变量立即生效：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="n"&gt;source&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;environment&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;经过了上述步骤，在命令行下敲：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ndk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bulid&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;弹出如下的错误，而不是说&lt;code&gt;ndk-build not found&lt;/code&gt;，就说明ndk环境已经安装成功了。&lt;/p&gt;
&lt;h3&gt;Windows下NDK环境搭建&lt;/h3&gt;
&lt;p&gt;在NDKr7开始，google的windos版NDK提供了一个ndk-build.cmd的脚本，这样就可以直接利用这个脚本编译，而不需要cygwin了。前面章节我介绍了NDK利用cygwin来进行配置（《NDK利用cygwin环境配置》），现在开始我们要与时俱进了,其实不同之处就是设置c/c++编译器的不同了。&lt;br /&gt;
1. 选择你的android工程，右击选择Properties，弹出配置界面，之后再点击Builders，弹出项目的编译编译工具        列表，之后点击new，新添加一个编译器，点击之后出现添加界面，选择Program，点击ok。
2. 出现了添加界面，我们先给编译器设置名称，如XXX_builder。
3. 设置Location为&lt;NDK安装目录&gt;\ndk-build.cmd
4. 设置Working Directory为${workspace_loc:/项目名称}&lt;br /&gt;
截图如下：&lt;br /&gt;
&lt;img alt="img" src="/images/ndk_configure.jpg" /&gt;&lt;br /&gt;
5. 切换到Refersh选项卡，给Refersh resources upon completion打上勾，选择The entire resource选项。&lt;br /&gt;
截图如下：&lt;br /&gt;
&lt;img alt="img" src="/images/ndk_configure2.jpg" /&gt;&lt;br /&gt;
6. 切换到Build Options选项卡，勾选上最后三项。再点击Specify Resource按钮，选择你的android工程的jni目录。&lt;br /&gt;
截图如下：&lt;br /&gt;
&lt;img alt="img" src="/images/ndk_configure3.jpg" /&gt;&lt;br /&gt;
7. 在编译工具列表，我们最好将我们新建的编译器置顶。选中点击Up按钮置顶。避免重复编译两次&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">CommonQ</dc:creator><pubDate>Wed, 30 Apr 2014 00:00:00 +0800</pubDate><guid>tag:commonq.github.io,2014-04-30:Android_ndk_1.html</guid><category>Android</category><category>NDK</category></item><item><title>Android JNI和NDK学习(2)--编程入门</title><link>http://commonq.github.io/Android_ndk_2.html</link><description>&lt;h3&gt;NDK代码编写&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;1. 首先是Java代码的编写&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Android NDK Sample里面的&lt;em&gt;Hello-jni&lt;/em&gt;工程.&lt;br /&gt;
&lt;em&gt;Hellojni.java&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Copyright (C) 2009 The Android Open Source Project&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);&lt;/span&gt;
&lt;span class="cm"&gt; * you may not use this file except in compliance with the License.&lt;/span&gt;
&lt;span class="cm"&gt; * You may obtain a copy of the License at&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; *      http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Unless required by applicable law or agreed to in writing, software&lt;/span&gt;
&lt;span class="cm"&gt; * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,&lt;/span&gt;
&lt;span class="cm"&gt; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/span&gt;
&lt;span class="cm"&gt; * See the License for the specific language governing permissions and&lt;/span&gt;
&lt;span class="cm"&gt; * limitations under the License.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;example&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hellojni&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;android.app.Activity&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;android.widget.TextView&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;android.os.Bundle&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;


&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HelloJni&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Activity&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/** Called when the activity is first created. */&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onCreate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="n"&gt;savedInstanceState&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onCreate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;savedInstanceState&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* Create a TextView and set its content.&lt;/span&gt;
&lt;span class="cm"&gt;         * the text is retrieved by calling a native&lt;/span&gt;
&lt;span class="cm"&gt;         * function.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="n"&gt;TextView&lt;/span&gt;  &lt;span class="n"&gt;tv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TextView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;tv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;stringFromJNI&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;setContentView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tv&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* A native method that is implemented by the&lt;/span&gt;
&lt;span class="cm"&gt;     * &amp;#39;hello-jni&amp;#39; native library, which is packaged&lt;/span&gt;
&lt;span class="cm"&gt;     * with this application.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;native&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;  &lt;span class="nf"&gt;stringFromJNI&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* This is another native method declaration that is *not*&lt;/span&gt;
&lt;span class="cm"&gt;     * implemented by &amp;#39;hello-jni&amp;#39;. This is simply to show that&lt;/span&gt;
&lt;span class="cm"&gt;     * you can declare as many native methods in your Java code&lt;/span&gt;
&lt;span class="cm"&gt;     * as you want, their implementation is searched in the&lt;/span&gt;
&lt;span class="cm"&gt;     * currently loaded native libraries only the first time&lt;/span&gt;
&lt;span class="cm"&gt;     * you call them.&lt;/span&gt;
&lt;span class="cm"&gt;     *&lt;/span&gt;
&lt;span class="cm"&gt;     * Trying to call this function will result in a&lt;/span&gt;
&lt;span class="cm"&gt;     * java.lang.UnsatisfiedLinkError exception !&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;native&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;  &lt;span class="nf"&gt;unimplementedStringFromJNI&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* this is used to load the &amp;#39;hello-jni&amp;#39; library on application&lt;/span&gt;
&lt;span class="cm"&gt;     * startup. The library has already been unpacked into&lt;/span&gt;
&lt;span class="cm"&gt;     * /data/data/com.example.hellojni/lib/libhello-jni.so at&lt;/span&gt;
&lt;span class="cm"&gt;     * installation time by the package manager.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;loadLibrary&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello-jni&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这段代码很简单，注释也很清晰，这里只提两点：:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;static&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; 
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;loadLibrary&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello-jni&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;表明程序开始运行的时候会加载hello-jni, static区声明的代码会先于onCreate方法执行,因为这是属于类的静态方法。如果你的程序中有多个类，而且如果HelloJni这个类不是你应用程序的入口，那么hello-jni（完整的名字是libhello-jni.so）这个库会在第一次使用HelloJni这个类的时候加载。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;native&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;stringFromJNI&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;native&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;unimplementedStringFromJNI&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到这两个方法的声明中有 native 关键字， 这个关键字表示这两个方法是本地方法，也就是说这两个方法是通过本地代码（C/C++）实现的，在java代码中仅仅是声明。&lt;/p&gt;
&lt;p&gt;用eclipse编译该工程，生成相应的.class文件，这步必须在下一步之前完成，因为生成.h文件需要用到相应的.class文件。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;2.编写C/C++代码&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;利用&lt;code&gt;javah&lt;/code&gt;这个工具生成相应的.h文件，然后根据这个.h文件编写相应的C/C++代码。&lt;/p&gt;
&lt;h4&gt;2.1 生成相应.h文件：&lt;/h4&gt;
&lt;p&gt;就拿我这的环境来说，首先在终端下进入刚刚建立的HelloJni工程的目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;~&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;workspace/android/NDK/hello-jni/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ls查看工程文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;~/workspace/android/NDK/hello-jni&lt;span class="nv"&gt;$ &lt;/span&gt;ls 
AndroidManifest.xml  assets  bin  default.properties  gen  res  src 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到目前仅仅有几个标准的android应用程序的文件（夹）。&lt;/p&gt;
&lt;p&gt;首先我们在工程目录下建立一个jni文件夹：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;~/workspace/android/NDK/hello-jni&lt;span class="nv"&gt;$ &lt;/span&gt;mkdir jni 
~/workspace/android/NDK/hello-jni&lt;span class="nv"&gt;$ &lt;/span&gt;ls 
AndroidManifest.xml  assets  bin  default.properties  gen  jni  res  src 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面就可以生成相应的.h文件了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;~/workspace/android/NDK/hello-jni&lt;span class="nv"&gt;$ &lt;/span&gt;javah -classpath bin -d jni com.example.hellojni.HelloJni 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-classpath bin：表示类的路劲&lt;/p&gt;
&lt;p&gt;-d jni: 表示生成的头文件存放的目录&lt;/p&gt;
&lt;p&gt;com.example.hellojni.HelloJni 则是完整类名  &lt;/p&gt;
&lt;p&gt;执行这个命令的时候可能会出错,因为需要加载android.jar关联类库.所以需要加上这个参数  &lt;/p&gt;
&lt;p&gt;-bootclasspath .../android.jar&lt;/p&gt;
&lt;p&gt;这一步的成功要建立在已经在 bin/com/example/hellojni/  目录下生成了 HelloJni.class的基础之上。&lt;/p&gt;
&lt;p&gt;现在可以看到jni目录下多了个.h文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;~/workspace/android/NDK/hello-jni&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;jni/ 
~/workspace/android/NDK/hello-jni/jni&lt;span class="nv"&gt;$ &lt;/span&gt;ls 
com_example_hellojni_HelloJni.h
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们来看看com_example_hellojni_HelloJni.h的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* DO NOT EDIT THIS FILE - it is machine generated */&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;jni.h&amp;gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Header for class com_example_hellojni_HelloJni */&lt;/span&gt;

&lt;span class="cp"&gt;#ifndef _Included_com_example_hellojni_HelloJni&lt;/span&gt;
&lt;span class="cp"&gt;#define _Included_com_example_hellojni_HelloJni&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Class:     com_example_hellojni_HelloJni&lt;/span&gt;
&lt;span class="cm"&gt; * Method:    stringFromJNI&lt;/span&gt;
&lt;span class="cm"&gt; * Signature: ()Ljava/lang/String;&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;JNIEXPORT&lt;/span&gt; &lt;span class="n"&gt;jstring&lt;/span&gt; &lt;span class="n"&gt;JNICALL&lt;/span&gt; &lt;span class="n"&gt;Java_com_example_hellojni_HelloJni_stringFromJNI&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JNIEnv&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jobject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Class:     com_example_hellojni_HelloJni&lt;/span&gt;
&lt;span class="cm"&gt; * Method:    unimplementedStringFromJNI&lt;/span&gt;
&lt;span class="cm"&gt; * Signature: ()Ljava/lang/String;&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;JNIEXPORT&lt;/span&gt; &lt;span class="n"&gt;jstring&lt;/span&gt; &lt;span class="n"&gt;JNICALL&lt;/span&gt; &lt;span class="nf"&gt;Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;JNIEnv&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;jobject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码中的JNIEXPORT 和 JNICALL 是jni的宏，在android的jni中不需要&lt;/p&gt;
&lt;p&gt;按照：java_pacakege_class_mathod 形式来命名。&lt;/p&gt;
&lt;p&gt;也就是说：&lt;/p&gt;
&lt;p&gt;Hello.java中 stringFromJNI() 方法对应于 C/C++中的Java_com_example_hellojni_HelloJni_stringFromJNI() 方法&lt;/p&gt;
&lt;h4&gt;2.2 编写Ｃ文件&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Copyright (C) 2009 The Android Open Source Project&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);&lt;/span&gt;
&lt;span class="cm"&gt; * you may not use this file except in compliance with the License.&lt;/span&gt;
&lt;span class="cm"&gt; * You may obtain a copy of the License at&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; *      http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Unless required by applicable law or agreed to in writing, software&lt;/span&gt;
&lt;span class="cm"&gt; * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,&lt;/span&gt;
&lt;span class="cm"&gt; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/span&gt;
&lt;span class="cm"&gt; * See the License for the specific language governing permissions and&lt;/span&gt;
&lt;span class="cm"&gt; * limitations under the License.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;jni.h&amp;gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* This is a trivial JNI example where we use a native method&lt;/span&gt;
&lt;span class="cm"&gt; * to return a new VM String. See the corresponding Java source&lt;/span&gt;
&lt;span class="cm"&gt; * file located at:&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; *   apps/samples/hello-jni/project/src/com/example/HelloJni/HelloJni.java&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;jstring&lt;/span&gt;
&lt;span class="nf"&gt;Java_com_example_hellojni_HelloJni_stringFromJNI&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;JNIEnv&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                                  &lt;span class="n"&gt;jobject&lt;/span&gt; &lt;span class="n"&gt;thiz&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;NewStringUTF&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello Wolrd JNI&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这里我们先不对&lt;code&gt;Android.mk&lt;/code&gt;文件做改动.android.mk在jni目录下，Android.mk 文件是Android 的 makefile文件，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Copyright (C) 2009 The Android Open Source Project&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;# Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);&lt;/span&gt;
&lt;span class="c"&gt;# you may not use this file except in compliance with the License.&lt;/span&gt;
&lt;span class="c"&gt;# You may obtain a copy of the License at&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;#      http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;# Unless required by applicable law or agreed to in writing, software&lt;/span&gt;
&lt;span class="c"&gt;# distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,&lt;/span&gt;
&lt;span class="c"&gt;# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/span&gt;
&lt;span class="c"&gt;# See the License for the specific language governing permissions and&lt;/span&gt;
&lt;span class="c"&gt;# limitations under the License.&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="nv"&gt;LOCAL_PATH&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;call my-dir&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;include $(CLEAR_VARS)&lt;/span&gt;

&lt;span class="nv"&gt;LOCAL_MODULE&lt;/span&gt;    &lt;span class="o"&gt;:=&lt;/span&gt; hello-jni
&lt;span class="nv"&gt;LOCAL_SRC_FILES&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; hello-jni.c

&lt;span class="cp"&gt;include $(BUILD_SHARED_LIBRARY)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在eclipse下进行重新编译.将生成的so库打包在apk内运行,就可以看到结果了.&lt;/p&gt;
&lt;h3&gt;To Be Continued&lt;/h3&gt;
&lt;p&gt;我会继续对&lt;code&gt;Android.mk&lt;/code&gt;文件做研究&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">CommonQ</dc:creator><pubDate>Wed, 30 Apr 2014 00:00:00 +0800</pubDate><guid>tag:commonq.github.io,2014-04-30:Android_ndk_2.html</guid><category>Android</category><category>NDK</category></item><item><title>Android JNI和NDK学习(3)--Android.mk分析</title><link>http://commonq.github.io/Android_ndk_3.html</link><description>&lt;h3&gt;参数解析&lt;/h3&gt;
&lt;p&gt;以刚才的&lt;code&gt;Android.mk&lt;/code&gt;为例.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Copyright (C) 2009 The Android Open Source Project&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;# Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);&lt;/span&gt;
&lt;span class="c"&gt;# you may not use this file except in compliance with the License.&lt;/span&gt;
&lt;span class="c"&gt;# You may obtain a copy of the License at&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;#      http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="c"&gt;# Unless required by applicable law or agreed to in writing, software&lt;/span&gt;
&lt;span class="c"&gt;# distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,&lt;/span&gt;
&lt;span class="c"&gt;# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/span&gt;
&lt;span class="c"&gt;# See the License for the specific language governing permissions and&lt;/span&gt;
&lt;span class="c"&gt;# limitations under the License.&lt;/span&gt;
&lt;span class="c"&gt;#&lt;/span&gt;
&lt;span class="nv"&gt;LOCAL_PATH&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;call my-dir&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="cp"&gt;include $(CLEAR_VARS)&lt;/span&gt;

&lt;span class="nv"&gt;LOCAL_MODULE&lt;/span&gt;    &lt;span class="o"&gt;:=&lt;/span&gt; hello-jni
&lt;span class="nv"&gt;LOCAL_SRC_FILES&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; hello-jni.c

&lt;span class="cp"&gt;include $(BUILD_SHARED_LIBRARY)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;LOCAL_PATH := $(call my-dir)&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;一个&lt;/span&gt;&lt;span class="n"&gt;Android&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mk&lt;/span&gt; &lt;span class="err"&gt;文件首先必须定义好&lt;/span&gt;&lt;span class="n"&gt;LOCAL_PATH&lt;/span&gt;&lt;span class="err"&gt;变量。它用于在开发树中查找源文件。在这个例子中，宏函数’&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;由编译系统提供，用于返回当前路径（即包含&lt;/span&gt;&lt;span class="n"&gt;Android&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mk&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="err"&gt;文件的目录）。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;include $( CLEAR_VARS)&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;CLEAR_VARS&lt;/span&gt;&lt;span class="err"&gt;由编译系统提供，指定让&lt;/span&gt;&lt;span class="n"&gt;GNU&lt;/span&gt; &lt;span class="n"&gt;MAKEFILE&lt;/span&gt;&lt;span class="err"&gt;为你清除许多&lt;/span&gt;&lt;span class="n"&gt;LOCAL_XXX&lt;/span&gt;&lt;span class="err"&gt;变量（例如&lt;/span&gt; &lt;span class="n"&gt;LOCAL_MODULE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LOCAL_SRC_FILES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LOCAL_STATIC_LIBRARIES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;等等&lt;/span&gt;&lt;span class="p"&gt;...),&lt;/span&gt; 
&lt;span class="err"&gt;除&lt;/span&gt;&lt;span class="n"&gt;LOCAL_PATH&lt;/span&gt; &lt;span class="err"&gt;。这是必要的，因为所有的编译控制文件都在同一个&lt;/span&gt;&lt;span class="n"&gt;GNU&lt;/span&gt; &lt;span class="n"&gt;MAKE&lt;/span&gt;&lt;span class="err"&gt;执行环境中，所有的变量都是全局的。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;LOCAL_MODULE := hello-jni&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;编译的目标对象，&lt;/span&gt;&lt;span class="n"&gt;LOCAL_MODULE&lt;/span&gt;&lt;span class="err"&gt;变量必须定义，以标识你在&lt;/span&gt;&lt;span class="n"&gt;Android&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mk&lt;/span&gt;&lt;span class="err"&gt;文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。&lt;/span&gt;

&lt;span class="err"&gt;注意：编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;jni&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;的共享库模块，将会生成&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;libhello&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;jni&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;文件。&lt;/span&gt;

&lt;span class="err"&gt;重要注意事项：&lt;/span&gt;

&lt;span class="err"&gt;如果你把库命名为‘&lt;/span&gt;&lt;span class="n"&gt;libhello&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;jni&lt;/span&gt;&lt;span class="err"&gt;’，编译系统将不会添加任何的&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="err"&gt;前缀，也会生成&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;libhello&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;jni&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;，这是为了支持来源于&lt;/span&gt;&lt;span class="n"&gt;Android&lt;/span&gt;&lt;span class="err"&gt;平台的源代码的&lt;/span&gt;&lt;span class="n"&gt;Android&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mk&lt;/span&gt;&lt;span class="err"&gt;文件，如果你确实需要这么做的话。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;LOCAL_SRC_FILES := hello-jni.c&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;LOCAL_SRC_FILES&lt;/span&gt;&lt;span class="err"&gt;变量必须包含将要编译打包进模块中的&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="err"&gt;或&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。&lt;/span&gt;

&lt;span class="err"&gt;注意，默认的&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;源码文件的扩展名是’&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;指定一个不同的扩展名也是可能的，只要定义&lt;/span&gt;&lt;span class="n"&gt;LOCAL_DEFAULT_CPP_EXTENSION&lt;/span&gt;&lt;span class="err"&gt;变量，不要忘记开始的小圆点（也就是’&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cxx&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;而不是’&lt;/span&gt;&lt;span class="n"&gt;cxx&lt;/span&gt;&lt;span class="err"&gt;’）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;include $(BUILD_SHARED_LIBRARY)&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BUILD_SHARED_LIBRARY&lt;/span&gt;&lt;span class="err"&gt;表示编译生成共享库，是编译系统提供的变量，指向一个&lt;/span&gt;&lt;span class="n"&gt;GNU&lt;/span&gt; &lt;span class="n"&gt;Makefile&lt;/span&gt;&lt;span class="err"&gt;脚本，负责收集自从上次调用&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;include&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLEAR_VARS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;以来，定义在&lt;/span&gt;&lt;span class="n"&gt;LOCAL_XXX&lt;/span&gt;&lt;span class="err"&gt;变量中的所有信息，并且决定编译什么，如何正确地去做。还有&lt;/span&gt; &lt;span class="n"&gt;BUILD_STATIC_LIBRARY&lt;/span&gt;&lt;span class="err"&gt;变量表示生成静态库：&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LOCAL_MODULE&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt; &lt;span class="n"&gt;BUILD_EXECUTABLE&lt;/span&gt; &lt;span class="err"&gt;表示生成可执行文件。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这里详细叙述一下Android.mk语法规范&lt;/p&gt;
&lt;h3&gt;Android.mk文件的用途&lt;/h3&gt;
&lt;p&gt;一个android子项目中会存在一个或多个Android.mk文件 &lt;br /&gt;
&lt;strong&gt;1、单一的Android.mk文件 &lt;/strong&gt;&lt;br /&gt;
直接参考NDK的sample目录下的hello-jni项目，在这个项目中只有一个Android.mk文件 &lt;br /&gt;
&lt;strong&gt;2、多个Android.mk文件   &lt;/strong&gt;
如果需要编译的模块比较多，我们可能会将对应的模块放置在相应的目录中， 
这样，我们可以在每个目录中定义对应的Android.mk文件（类似于上面的写法）， 
最后，在根目录放置一个Android.mk文件，内容如下： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;include&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;subdir&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;makefiles&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只需要这一行就可以了，它的作用就是包含所有子目录中的Android.mk文件  &lt;br /&gt;
&lt;strong&gt;3、多个模块共用一个Android.mk &lt;/strong&gt;&lt;br /&gt;
这个文件允许你将源文件组织成模块，这个模块中含有： &lt;br /&gt;
  -静态库(.a文件) &lt;br /&gt;
  -动态库(.so文件) &lt;br /&gt;
只有共享库才能被安装/复制到您的应用软件（APK）包中 &lt;br /&gt;
&lt;code&gt;include $(BUILD_STATIC_LIBRARY)&lt;/code&gt;，编译出的是静态库 &lt;br /&gt;
&lt;code&gt;include $(BUILD_SHARED_LIBRARY)&lt;/code&gt;，编译出的是动态库   &lt;/p&gt;
&lt;h3&gt;自定义变量&lt;/h3&gt;
&lt;p&gt;以下是在 Android.mk中依赖或定义的变量列表，可以定义其他变量为自己使用，但是NDK编译系统保留下列变量名：&lt;br /&gt;
-以 LOCAL_开头的名字（例如 LOCAL_MODULE） &lt;br /&gt;
-以 PRIVATE_, NDK_ 或 APP_开头的名字（内部使用） &lt;br /&gt;
-小写名字（内部使用，例如‘my-dir’） &lt;br /&gt;
如果为了方便在 Android.mk 中定义自己的变量，建议使用 MY_前缀，一个小例子： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MY_SOURCES&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;foo1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; 
&lt;span class="n"&gt;ifneq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MY_CONFIG_BAR&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt; 
&lt;span class="n"&gt;MY_SOURCES&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; 
&lt;span class="n"&gt;endif&lt;/span&gt; 
&lt;span class="n"&gt;LOCAL_SRC_FILES&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MY_SOURCES&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：‘:=’是赋值的意思；'+='是追加的意思；‘$’表示引用某变量的值。 &lt;/p&gt;
&lt;h3&gt;GNU Make系统变量&lt;/h3&gt;
&lt;p&gt;这些 GNU Make变量在你的 Android.mk 文件解析之前，就由编译系统定义好了。注意在某些情况下，NDK可能分析 Android.mk 几次，每一次某些变量的定义会有不同。   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CLEAR_VALS&lt;br /&gt;
指向一个编译脚本，几乎所有未定义的 LOCAL_XXX 变量都在"Module-description"节中列出。必须在开始一个新模块之前包含这个脚本：include$(CLEAR_VARS)，用于重置除LOCAL_PATH变量外的，所有LOCAL_XXX系列变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUILD_SHARED_LIBRARY:&lt;br /&gt;
指向编译脚本，根据所有的在 LOCAL_XXX 变量把列出的源代码文件编译成一个共享库。 &lt;br /&gt;
注意，必须至少在包含这个文件之前定义 LOCAL_MODULE 和 LOCAL_SRC_FILES。   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUILD_STATIC_LIBRARY: &lt;br /&gt;
一个 BUILD_SHARED_LIBRARY 变量用于编译一个静态库。静态库不会复制到的APK包中，但是能够用于编译共享库。 
示例：include $(BUILD_STATIC_LIBRARY) 
注意，这将会生成一个名为 lib$(LOCAL_MODULE).a 的文件 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;TARGET_ARCH: 目标 CPU平台的名字 &lt;/li&gt;
&lt;li&gt;TARGET_PLATFORM: Android.mk 解析的时候，目标 Android 平台的名字.详情可考/development/ndk/docs/stable- apis.txt. 
       android-3 -&amp;gt; Official Android 1.5 system images 
       android-4 -&amp;gt; Official Android 1.6 system images 
       android-5 -&amp;gt; Official Android 2.0 system images &lt;/li&gt;
&lt;li&gt;TARGET_ARCH_ABI:  暂时只支持两个 value，armeabi 和 armeabi-v7a。。 &lt;/li&gt;
&lt;li&gt;TARGET_ABI: 目标平台和 ABI 的组合， &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;模块描述变量&lt;/h3&gt;
&lt;p&gt;下面的变量用于向编译系统描述你的模块。应该定义在'include  $(CLEAR_VARS)'和'include $(BUILD_XXXXX)'之间。$(CLEAR_VARS)是一个脚本，清除所有这些变量。   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LOCAL_PATH:  这个变量用于给出当前文件的路径。
       必须在 Android.mk 的开头定义，可以这样使用：LOCAL_PATH := $(call my-dir) 
       如当前目录下有个文件夹名称 src，则可以这样写 $(call src)，那么就会得到 src 目录的完整路径 
       这个变量不会被$(CLEAR_VARS)清除，因此每个 Android.mk 只需要定义一次(即使在一个文件中定义了几个模块的情况下)。 &lt;/li&gt;
&lt;li&gt;LOCAL_MODULE: 这是模块的名字，它必须是唯一的，而且不能包含空格。 
       必须在包含任一的$(BUILD_XXXX)脚本之前定义它。模块的名字决定了生成文件的名字。 &lt;/li&gt;
&lt;li&gt;LOCAL_SRC_FILES:  这是要编译的源代码文件列表。 
       只要列出要传递给编译器的文件，因为编译系统自动计算依赖。注意源代码文件名称都是相对于 LOCAL_PATH的，你可以使用路径部分，例如： 
        LOCAL_SRC_FILES := foo.c toto/bar.c\ 
        Hello.c 
       文件之间可以用空格或Tab键进行分割,换行请用"\" 
       如果是追加源代码文件的话，请用LOCAL_SRC_FILES += 
       注意：可以LOCAL_SRC_FILES := $(call all-subdir-java-files)这种形式来包含local_path目录下的所有java文件。 &lt;/li&gt;
&lt;li&gt;LOCAL_C_INCLUDES:  可选变量，表示头文件的搜索路径。 
        默认的头文件的搜索路径是LOCAL_PATH目录。 &lt;/li&gt;
&lt;li&gt;LOCAL_STATIC_LIBRARIES: 表示该模块需要使用哪些静态库，以便在编译时进行链接。 &lt;/li&gt;
&lt;li&gt;LOCAL_SHARED_LIBRARIES:  表示模块在运行时要依赖的共享库（动态库），在链接时就需要，以便在生成文件时嵌入其相应的信息。 
       注意：它不会附加列出的模块到编译图，也就是仍然需要在Application.mk 中把它们添加到程序要求的模块中。 &lt;/li&gt;
&lt;li&gt;LOCAL_LDLIBS:  编译模块时要使用的附加的链接器选项。这对于使用‘-l’前缀传递指定库的名字是有用的。 
       例如，LOCAL_LDLIBS := -lz表示告诉链接器生成的模块要在加载时刻链接到/system/lib/libz.so 
       可查看 docs/STABLE-APIS.TXT 获取使用 NDK发行版能链接到的开放的系统库列表。 &lt;/li&gt;
&lt;li&gt;LOCAL_MODULE_PATH 和 LOCAL_UNSTRIPPED_PATH 
       在 Android.mk 文件中， 还可以用LOCAL_MODULE_PATH 和LOCAL_UNSTRIPPED_PATH指定最后的目标安装路径. 
       不同的文件系统路径用以下的宏进行选择： 
       TARGET_ROOT_OUT：表示根文件系统。 
       TARGET_OUT：表示 system文件系统。 
       TARGET_OUT_DATA：表示 data文件系统。 
       用法如：LOCAL_MODULE_PATH :=$(TARGET_ROOT_OUT) 
       至于LOCAL_MODULE_PATH 和LOCAL_UNSTRIPPED_PATH的区别，暂时还不清楚。 &lt;/li&gt;
&lt;li&gt;LOCAL_JNI_SHARED_LIBRARIES：定义了要包含的so库文件的名字，如果程序没有采用jni，不需要 
        LOCAL_JNI_SHARED_LIBRARIES := libxxx 这样在编译的时候，NDK自动会把这个libxxx打包进apk； 放在youapk/lib/目录下 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;NDK提供的函数宏&lt;/h3&gt;
&lt;p&gt;GNU Make函数宏，必须通过使用'$(call  )'来调用，返回值是文本化的信息。   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;my-dir:返回当前 Android.mk 所在的目录的路径，相对于 NDK 编译系统的顶层。这是有用的，在 Android.mk 文件的开头如此定义： 
        LOCAL_PATH := $(call my-dir) &lt;/li&gt;
&lt;li&gt;all-subdir-makefiles: 返回一个位于当前'my-dir'路径的子目录中的所有Android.mk的列表。 
       例如，某一子项目的目录层次如下： 
            src/foo/Android.mk 
            src/foo/lib1/Android.mk 
            src/foo/lib2/Android.mk 
      如果 src/foo/Android.mk 包含一行： 
           include $(call all-subdir-makefiles) 
      那么它就会自动包含 src/foo/lib1/Android.mk 和 src/foo/lib2/Android.mk。 
      这项功能用于向编译系统提供深层次嵌套的代码目录层次。 
      注意，在默认情况下，NDK 将会只搜索在 src/*/Android.mk 中的文件。 &lt;/li&gt;
&lt;li&gt;this-makefile:  返回当前Makefile 的路径(即这个函数调用的地方) &lt;/li&gt;
&lt;li&gt;parent-makefile:  返回调用树中父 Makefile 路径。即包含当前Makefile的Makefile 路径。 &lt;/li&gt;
&lt;li&gt;grand-parent-makefile：返回调用树中父Makefile的父Makefile的路径 &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Android.mk示例&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#编译静态库  &lt;/span&gt;
&lt;span class="nv"&gt;LOCAL_PATH&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;call my-dir&lt;span class="k"&gt;)&lt;/span&gt;  
&lt;span class="cp"&gt;include $(CLEAR_VARS)  &lt;/span&gt;
&lt;span class="nv"&gt;LOCAL_MODULE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; libhellos  
&lt;span class="nv"&gt;LOCAL_CFLAGS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;L_CFLAGS&lt;span class="k"&gt;)&lt;/span&gt;  
&lt;span class="nv"&gt;LOCAL_SRC_FILES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; hellos.c  
&lt;span class="nv"&gt;LOCAL_C_INCLUDES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;INCLUDES&lt;span class="k"&gt;)&lt;/span&gt;  
&lt;span class="nv"&gt;LOCAL_SHARED_LIBRARIES&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; libcutils  
&lt;span class="nv"&gt;LOCAL_COPY_HEADERS_TO&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; libhellos  
&lt;span class="nv"&gt;LOCAL_COPY_HEADERS&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; hellos.h  
&lt;span class="cp"&gt;include $(BUILD_STATIC_LIBRARY)  &lt;/span&gt;

&lt;span class="c"&gt;#编译动态库  &lt;/span&gt;
&lt;span class="nv"&gt;LOCAL_PATH&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;call my-dir&lt;span class="k"&gt;)&lt;/span&gt;  
&lt;span class="cp"&gt;include $(CLEAR_VARS) &lt;/span&gt;
&lt;span class="nv"&gt;LOCAL_MODULE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; libhellod 
&lt;span class="nv"&gt;LOCAL_CFLAGS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;L_CFLAGS&lt;span class="k"&gt;)&lt;/span&gt; 
&lt;span class="nv"&gt;LOCAL_SRC_FILES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; hellod.c 
&lt;span class="nv"&gt;LOCAL_C_INCLUDES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;INCLUDES&lt;span class="k"&gt;)&lt;/span&gt; 
&lt;span class="nv"&gt;LOCAL_SHARED_LIBRARIES&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; libcutils 
&lt;span class="nv"&gt;LOCAL_COPY_HEADERS_TO&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; libhellod 
&lt;span class="nv"&gt;LOCAL_COPY_HEADERS&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; hellod.h 
&lt;span class="cp"&gt;include $(BUILD_SHARED_LIBRARY) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">CommonQ</dc:creator><pubDate>Wed, 30 Apr 2014 00:00:00 +0800</pubDate><guid>tag:commonq.github.io,2014-04-30:Android_ndk_3.html</guid><category>Android</category><category>NDK</category></item><item><title>用Pelican和Github Pages在Linux上搭建个人博客</title><link>http://commonq.github.io/build_my_blog.html</link><description>&lt;h3&gt;搭建环境&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;Linux&lt;/code&gt;环境下搭建，采用&lt;code&gt;ubuntu&lt;/code&gt;，使用其它发行版过程基本相同。&lt;/p&gt;
&lt;h3&gt;Github Pages&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;注册&lt;code&gt;Github&lt;/code&gt;,注册和配置&lt;code&gt;SSH&lt;/code&gt;密钥过程&lt;a href="http://help.github.com/articles/set-up-git"&gt;help page&lt;/a&gt;写得很清楚。&lt;/li&gt;
&lt;li&gt;不过现在github支持http传输良好，所以也可以不用配置ＳＳＨ，通过用户名密码即可登录。&lt;/li&gt;
&lt;li&gt;在Github创建一个名为username.github.io的版本库（将username替换成自己的Github账户名）。&lt;/li&gt;
&lt;li&gt;Setting -&amp;gt; Automatic page generator -&amp;gt; Continue to layout，选择一个模板，并发布。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;十分钟后在&lt;code&gt;username.github.io&lt;/code&gt;页面就已经生成了一个页面。访问该网址即可看到。&lt;/p&gt;
&lt;h3&gt;配置本地环境&lt;/h3&gt;
&lt;h4&gt;安装Ｐｅｌｉｃａｎ和Ｍａｒｋｄｏｗｎ：&lt;/h4&gt;
&lt;p&gt;在这里我没有用&lt;code&gt;Jekyll&lt;/code&gt;因为它是&lt;code&gt;Ｒｕｂｙ&lt;/code&gt;写的对它没什么兴趣。所以我采用&lt;code&gt;Ｐｙｔｈｏｎ&lt;/code&gt;编写的&lt;code&gt;Ｐｅｌｉｃａｎ&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;介绍&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Pelican&lt;/code&gt;是一套开源的使用&lt;code&gt;Python&lt;/code&gt;编写的博客静态生成, 可以添加文章和和创建页面, 可以使用&lt;code&gt;MarkDown&lt;/code&gt; &lt;code&gt;reStructuredText&lt;/code&gt; 和 &lt;code&gt;AsiiDoc&lt;/code&gt; 的格式来抒写, 同时使用 &lt;code&gt;Disqus&lt;/code&gt;评论系统, 支持 &lt;code&gt;RSS&lt;/code&gt;和&lt;code&gt;Atom&lt;/code&gt;输出, 插件, 主题, 代码高亮等功能, 采用&lt;code&gt;Jajin2&lt;/code&gt;模板引擎, 可以很容易的更改模板&lt;/p&gt;
&lt;h4&gt;安装&lt;/h4&gt;
&lt;p&gt;安装&lt;code&gt;Ｐｅｌｉｃａｎ&lt;/code&gt;有很多种方法。一种使用&lt;code&gt;ｐｙｔｈｏｎ&lt;/code&gt;的包管理器&lt;code&gt;ｐｉｐ&lt;/code&gt;进行安装。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$sudo&lt;/span&gt; apt-get install python-pip
&lt;span class="nv"&gt;$sudo&lt;/span&gt; pip install pelican
&lt;span class="nv"&gt;$sudo&lt;/span&gt; pip install markdown
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另一种就是从&lt;code&gt;ｇｉｔｈｕｂ&lt;/code&gt;上克隆&lt;code&gt;Ｐｅｌｉｃａｎ&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git clone git://github.com/getpelican/pelican.git       
&lt;span class="nb"&gt;cd &lt;/span&gt;pelican
python setup.py install
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;写第一篇博客&lt;/h3&gt;
&lt;h4&gt;搭建目录&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir blog
&lt;span class="nb"&gt;cd &lt;/span&gt;blog
pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在回答一系列问题过后你的博客就建成的, 主要生成下列文件:
生成的目录结构:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;blog/
├── content
│   └── *.md             &lt;span class="c"&gt;# markdown文件&lt;/span&gt;
├── output               &lt;span class="c"&gt;# 默认的输出目录&lt;/span&gt;
├── develop_server.sh
├── Makefile
├── pelicanconf.py       &lt;span class="c"&gt;# 主配置文件&lt;/span&gt;
└── publishconf.py
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;写一篇文章&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;content&lt;/code&gt;目录新建一个 &lt;code&gt;test.md&lt;/code&gt;文件, 填入一下内容:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;Title:&lt;/span&gt; &lt;span class="err"&gt;文章标题&lt;/span&gt;
&lt;span class="nl"&gt;Date:&lt;/span&gt; &lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mo"&gt;04&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;
&lt;span class="nl"&gt;Category:&lt;/span&gt; &lt;span class="err"&gt;文章类别&lt;/span&gt;
&lt;span class="nl"&gt;Tag:&lt;/span&gt; &lt;span class="err"&gt;标签&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;标签&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="err"&gt;这里是内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;生成了&lt;code&gt;ｈｔｍｌ&lt;/code&gt;。然后执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./develop_server.sh start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;开启一个测试服务器, 这会在本地 8000 端口建立一个测试web服务器, 可以使用浏览器打开:&lt;code&gt;http://localhost:8000&lt;/code&gt;来访问这个测试服务器, 然后就可以欣赏到你的博客了&lt;/p&gt;
&lt;h4&gt;创建一个Ａｂｏｕｔ页面&lt;/h4&gt;
&lt;p&gt;这里以创建 About页面为例&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;content&lt;/code&gt;目录创建pages目录&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir content/pages
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后创建&lt;code&gt;About.md&lt;/code&gt;并填入下面内容&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;About&lt;/span&gt; &lt;span class="n"&gt;Me&lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;04&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;

&lt;span class="n"&gt;About&lt;/span&gt; &lt;span class="n"&gt;me&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行 &lt;code&gt;make html&lt;/code&gt; 生成&lt;code&gt;html&lt;/code&gt;, 然后打开&lt;code&gt;http://localhost:8000&lt;/code&gt;查看效果&lt;/p&gt;
&lt;h3&gt;使用Ｐｅｌｉｃａｎ支持评论&lt;/h3&gt;
&lt;p&gt;使用&lt;a href="http://disqus.com/"&gt;Disqus&lt;/a&gt;作为评论系统，注册帐号后直接在pelicanconf.conf中添加:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;your_shortname&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用浏览器打开:&lt;code&gt;http://localhost:8000&lt;/code&gt;来查看效果&lt;/p&gt;
&lt;h3&gt;主题&lt;/h3&gt;
&lt;p&gt;安装主题：
Ｐｅｌｉｃａｎ本身提供很多主题可供选择，可以从&lt;code&gt;ｇｉｔｈｕｂ&lt;/code&gt;上&lt;code&gt;ｃｌｏｎｅ&lt;/code&gt;下来&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git clone https://github.com/getpelican/pelican-themes.git
&lt;span class="nb"&gt;cd &lt;/span&gt;pelican-themes
pelican-themes -i bootstrap2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;bootstrap2&lt;/code&gt;是选择使用的主题，&lt;a href="http://github.com/getpelican/pelican-themes"&gt;pelican主题的Github目录&lt;/a&gt;下几乎每个都提供了预览.&lt;/p&gt;
&lt;p&gt;然后，在配置文件&lt;code&gt;pelicanconf.py&lt;/code&gt;中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;THEME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;bootstrap2&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重新make，就生成了带有选定主题的页面。&lt;/p&gt;
&lt;h3&gt;使用插件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Pelican&lt;/code&gt; 一开始是将插件内置的, 但是新版本 &lt;code&gt;Pelican&lt;/code&gt;将插件隔离了出来, 所以我们要到github上 克隆一份新的插件, 在博客目录执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git clone git://github.com/getpelican/pelican-plugins.git    
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在我们博客目录就新添了一个 &lt;code&gt;pelican-plugins&lt;/code&gt;目录, 我们已配置sitemap插件为例, sitemap插件可以生成 sitemap.xml 供搜索引擎使用&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;pelicanconf.py&lt;/code&gt;配置文件里加上如下项:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;PLUGIN_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;pelican-plugins&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sitemap&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置sitemap 插件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;SITEMAP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;format&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;priorities&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;changefreqs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;daily&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后再执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打开浏览器请求 &lt;code&gt;http://localhost:8000/sitemap.xml&lt;/code&gt;即可看到生成的 Sitemap 了&lt;/p&gt;
&lt;h3&gt;添加Google Analytics&lt;/h3&gt;
&lt;p&gt;去Google Analytics申请账号，记下跟踪ID。 在pelicanconf.py添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;GOOGLE_ANALYTICS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;跟踪&lt;/span&gt;&lt;span class="n"&gt;ID&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用Google Webmasters&lt;/h3&gt;
&lt;p&gt;在&lt;a href="http://www.google.com/webmasters/"&gt;Google Webmasters&lt;/a&gt;上注册即可。
这个就是Google站长工具，使用它的目的是为了让博客被Google更好的收录，比如手动让Googlebot抓取、提交Robots、更新Sitemap等等，各方面完爆百度站长工具。&lt;/p&gt;
&lt;h3&gt;上传Ｇｉｔｈｕｂ&lt;/h3&gt;
&lt;p&gt;最后在你的&lt;code&gt;ｏｕｔｐｕｔ&lt;/code&gt;文件夹内&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git init
git add .
git commit -m &lt;span class="s1"&gt;&amp;#39;first commit&amp;#39;&lt;/span&gt; 
git remote add origin git@github.com:yourname/yourname.github.io.git
git push -u origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就大功告成了！&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">CommonQ</dc:creator><pubDate>Tue, 22 Apr 2014 00:00:00 +0800</pubDate><guid>tag:commonq.github.io,2014-04-22:build_my_blog.html</guid><category>Blog</category><category>Github</category><category>Pelican</category><category>Linux</category></item><item><title>第一篇博客</title><link>http://commonq.github.io/first_blog.html</link><description>&lt;h3&gt;纪念&lt;/h3&gt;
&lt;p&gt;2014年4月22日搭建了一天的博客终于成功了，在此留念！&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">CommonQ</dc:creator><pubDate>Tue, 22 Apr 2014 00:00:00 +0800</pubDate><guid>tag:commonq.github.io,2014-04-22:first_blog.html</guid><category>Blog</category><category>Mood</category></item></channel></rss>